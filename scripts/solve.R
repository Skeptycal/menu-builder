# GNU solver
# https://cran.r-project.org/web/packages/Rglpk/Rglpk.pdf

source("./scripts/menu_builder_silent.R")   # Load all original menu building and tweaking functions but 
                                            # only create the original menu
source("./scripts/transpose_menu.R")   

# devtools::install_github("aedobbyn/dobtools", force = TRUE)
library(dobtools)
library(feather)
library(Rglpk)

# --------------------------------------------------------------------------------------------------
# Now in dobtools
grab_first_word <- function(e, splitter = " ") {
  stopifnot(is.character(e))
  
  e <- e %>% stringr::str_split(pattern = splitter, simplify = TRUE) %>% first()
  return(e)
}

is_plural <- function(word, return_bool = FALSE) {
  
  if(substr(word, nchar(word), nchar(word)) %>% tolower() == "s") {
    is_plural_bool <- TRUE
    word_to_say <- "them"
  } else {
    is_plural_bool <- FALSE
    word_to_say <- "it"
  }
  
  if(return_bool == TRUE) {
    return(is_plural_bool)
  } else {
    return(word_to_say)
  }
  
}
# --------------------------------------------------------------------------------------------------


# Quosure the nutrient and must restrict names
nutrient_names <- c(all_nut_and_mr_df$nutrient, "Energ_Kcal")
quo_nutrient_names <- quo(nutrient_names)

# Simplify our menu space
cols_to_keep <- c(all_nut_and_mr_df$nutrient, "Shrt_Desc", "GmWt_1", "Energ_Kcal", "NDB_No")

do_menu_mutates <- function(menu) {

  menu_unsolved_per_g <- menu[, which(names(menu) %in% cols_to_keep)] %>% 
    mutate(
      shorter_desc = map_chr(Shrt_Desc, grab_first_word, splitter = ","), # Take only the fist word
      cost = runif(nrow(.), min = 1, max = 10) %>% round(digits = 2) # Add a cost column
      # serving_gmwt = GmWt_1   # Single serving gram weight
    ) %>%
    select(shorter_desc, cost, !!quo_nutrient_names, GmWt_1, Shrt_Desc, NDB_No) #  serving_gmwt,
  
  return(menu_unsolved_per_g)
}

menu_unsolved_per_g <- do_menu_mutates(menu)


# Give nutrients a flag for whether they're a must-restrict or not
nutrient_df <- all_nut_and_mr_df %>% 
  bind_rows(list(nutrient = "Energ_Kcal",     # Add calorie restriction in
                 value = 2300) %>% as_tibble()) %>%
  mutate(
    is_must_restrict = ifelse(nutrient %in% mr_df$must_restrict, TRUE, FALSE)
  )


# -----------------------------------------
# What we have in our menu right now after it's just been generated by build_menu():
  # One serving of every food
  # Each nutrient's value represents how much of that nutrient we have per 100g 
  # GmWt_1 represents how many grams are in the food (in 1 serving of the food, until we adjust this)
  # To get the raw g of that nutrient, we have to multiply the nutrient per 100g value by GmWt_1 and divide by 100

# We use raw g of each nutrient in the linear program because only addition is allowed, but we want to 
# end up with a menu in the same format as what we started with, i.e., value of each nutrient per 
# 100g (this doesn't change) and the weight of the food in our menu -- this is what does change
# since we don't manipulate nutrients directly, we manipulate the GmWt_1 of each of the foods.


# needs_transforming <- function(col) {
#   if (col %in% nutrient_names) {
#     needs_transforming <- TRUE
#   } else {
#     needs_transforming <- FALSE
#   }
#   return(needs_transforming)
# }
# 
# get_val_per_gram <- function(col) {
#   col = col * GmWt_1
#   return(col)
# }
# 
# menu_unsolved <- menu_unsolved_raw %>% 
#   transmute_if(needs_transforming, get_val_per_gram)


# at_cols <- which(names(menu_unsolved_raw) %in% nutrient_names)
# 
# per_g_vals <- menu_unsolved_raw %>% 
#   select(GmWt_1, !!quo_nutrient_names) %>%
#   map_dfr(function(x) (x * .$GmWt_1)/100) %>%         # .at = at_cols
#   select(-GmWt_1)
# 
# non_nut_cols <- menu_unsolved_raw[, setdiff(seq(1:ncol(menu_unsolved_raw)), at_cols)]
# 
# menu_unsolved <- per_g_vals %>% bind_cols(non_nut_cols) %>% 
#   select(shorter_desc, cost, !!quo_nutrient_names, Shrt_Desc, NDB_No)


# -------------- Menu transforms -----------
# GmWt_1 is always the total gram weight -- the same between types of menus

# Get raw nutrient values per food by multiplying the per 100g amounts by GmWt_1 and dividing by 100
get_raw_vals <- function(df){
  at_cols <- which(names(df) %in% nutrient_names)
  non_nut_cols <- df[, setdiff(seq(1:ncol(df)), at_cols)]
  
  raw_vals <- df %>% 
    select(GmWt_1, !!quo_nutrient_names) %>%
    map_dfr(function(x) (x * .$GmWt_1)/100) %>%         # .at = at_cols
    select(-GmWt_1)
  
  out <- raw_vals %>% bind_cols(non_nut_cols) %>% 
    select(shorter_desc, GmWt_1, cost, !!quo_nutrient_names, Shrt_Desc, NDB_No)
  
  return(out)
}
menu_unsolved_raw <- get_raw_vals(menu_unsolved_per_g)


# Backtransform: get per 100g nutrient values from the raw
get_per_g_vals <- function(df) {
  at_cols <- which(names(df) %in% nutrient_names)
  non_nut_cols <- df[, setdiff(seq(1:ncol(df)), at_cols)]
  
  # browser()
  
  per_g_vals <- df %>%
    select(GmWt_1, !!quo_nutrient_names) %>%
    map_dfr(function(x) (x / .$GmWt_1)*100) %>% 
    select(-GmWt_1)
  
  out <- per_g_vals %>% bind_cols(non_nut_cols) %>%
    bind_cols(GmWt_1 = df$GmWt_1) %>% 
    select(shorter_desc, GmWt_1, cost, !!quo_nutrient_names, Shrt_Desc, NDB_No)
  
  return(out)
}
get_per_g_vals(menu_unsolved_raw)




# ---------- Transpose ----------
# Take a look at what the constraing matrix will look like 
menu_unsolved_per_g %>% transpose_menu()
menu_unsolved_per_g %>% get_raw_vals() %>% transpose_menu()




# # # # # # # # # # # # # # # # # # # # Solve  # # # # # # # # # # # # # # # # # # # # # # # #

# Return a solution that contains the original menu and the needed nutrient df along with the rest
# of the solution in a list
solve_it <- function(df, nutrient_df, df_is_per_100g = TRUE, only_full_servings = FALSE, 
                     min_food_amount = 1, max_food_amount = 100, 
                     verbose = TRUE, v_v_verbose = FALSE, maximize = FALSE) {
  
  # If our nutrient values are per 100g (i.e., straight from menu_builder)
  if (df_is_per_100g == TRUE) {
    df_per_100g <- df        # Save our original df in df_per_100g
    df <- get_raw_vals(df)   # Get the raw values
  } else {
    df_per_100g <- get_per_g_vals(df)
  }
  
  n_foods <- length(df$shorter_desc)
  nut_quo <- quo(nutrient_df$nutrient)
  
  dir_mr <- rep("<", nutrient_df %>% filter(is_must_restrict == TRUE) %>% ungroup() %>% count() %>% as_vector())       # And less than on all the must_restricts
  dir_pos <- rep(">", nutrient_df %>% filter(is_must_restrict == FALSE) %>% ungroup() %>% count() %>% as_vector())     # Final menu must be greater than on all the positives
  
  dir <- c(dir_mr, dir_pos)
  rhs <- nutrient_df[["value"]]      # The right-hand side of the equation is all of the min or max nutrient values
  obj_fn <- df[["cost"]]             # Objective function will be to minimize total cost
  
  bounds <- list(lower = list(ind = seq(n_foods), 
                              val = rep(min_food_amount, n_foods)),
                 upper = list(ind = seq(n_foods), 
                              val = rep(max_food_amount, n_foods)))
  
  construct_matrix <- function(df, nutrient_df) {       # Set up matrix constraints
    mat_base <- df %>% select(!!nut_quo) %>% as_vector()    # Get a vector of all our nutrients
    mat <- matrix(mat_base, nrow = nrow(nutrient_df), byrow = TRUE)       # One row per constraint, one column per food (variable)
    return(mat)
  }
  
  mat <- construct_matrix(df, nutrient_df)
  constraint_matrix <- mat %>% as_data_frame() 
  names(constraint_matrix) <- str_c(df$shorter_desc,  # Use combo of shorter_desc and NDB_No
                                    df$NDB_No, sep = ", ")  # so that names are interpretable but also unique
  constraint_matrix <- constraint_matrix %>% 
    mutate(
      dir = dir,
      rhs = rhs
    ) %>% left_join(nutrient_df, by = c("rhs" = "value")) %>% 
    select(nutrient, everything())
  
  if(only_full_servings == TRUE) {    # Integer values of coefficients if only full servings
    types <- rep("I", n_foods)
  } else {
    types <- rep("C", n_foods)
  }
  
  if(v_v_verbose == TRUE) {
    v_v_verbose <- TRUE
    message("Constraint matrix below:")
    print(constraint_matrix)
  } else {
    v_v_verbose <- FALSE
  }
  
  out <- Rglpk_solve_LP(obj_fn, mat, dir, rhs,                    # Do the solving; we get a list back
                        bounds = bounds, types = types, 
                        max = maximize, verbose = v_v_verbose)   
  
  out <- append(append(append(                                           # Append the dataframe of all min/max nutrient values
    out, list(necessary_nutrients = nutrient_df)),
    list(constraint_matrix = constraint_matrix)),                        # our constraint matrix
    list(original_menu_raw = df))                                            # and our original menu
  
  if (!is.null(df_per_100g)) {
    out <- append(out, list(original_menu_per_g = df_per_100g))
  }
  
  if (verbose == TRUE) {
    message(paste0("Cost is $", round(out$optimum, digits = 2), ".")) 
    if (out$status == 0) {
      message("Optimal solution found :)")
    } else {
      message("No optimal solution found :'(")
    }
  }
  
  return(out)
}
solve_it(menu_unsolved_per_g, nutrient_df, only_full_servings = TRUE, v_v_verbose = TRUE, min_food_amount = 0.5)$solution
solve_it(menu_unsolved_per_g, nutrient_df, only_full_servings = FALSE, min_food_amount = -0.5)$solution

solve_it(menu_unsolved_raw, nutrient_df, df_is_per_100g = FALSE)
solve_it(menu_unsolved_per_g, nutrient_df, min_food_amount = -3)

full_solution <- solve_it(menu_unsolved_per_g, nutrient_df, min_food_amount = -1)



# Take a solution (a list resulting from solve_it()) and 
# return a menu with the solution column cbound as well as a helpful message
solve_menu <- function(sol, v_v_verbose = TRUE) {
  
  solved_col <-  list(solution_amounts = sol$solution) %>% as_tibble()    # Grab the vector of solution amounts
  
  df_solved <- sol$original_menu_per_g %>% bind_cols(solved_col) %>%            # cbind that to the original menu
    select(shorter_desc, solution_amounts, GmWt_1, everything()) %>% 
    mutate(
      GmWt_1 = GmWt_1 * solution_amounts,
      cost = cost * solution_amounts
    ) 
  
  max_food <- df_solved %>%                                   # Find what the most of any one food we've got is
    filter(solution_amounts == max(df_solved$solution_amounts)) %>% 
    slice(1:1)                                           # If we've got multiple maxes, take only the first
  
  if (v_v_verbose == TRUE) {
    message(paste0("We've got a lot of ", max_food$shorter_desc %>% as_vector()), ". ",
            max_food$solution_amounts %>% round(digits = 2), " servings of ",
            max_food$shorter_desc %>% as_vector() %>% is_plural(return_bool = FALSE), ".")  
  }
  
  return(df_solved)
}

solve_menu(full_solution)
solved_menu <- menu_unsolved_per_g %>% solve_it(nutrient_df, min_food_amount = 1) %>% solve_menu()

compliant_solved <- solve_it(menu_unsolved_per_g, nutrient_df, 
                             only_full_servings = TRUE, min_food_amount = -2) %>% solve_menu()


# Test compliance
compliant_solved %>% test_all_compliance_verbose()
solved_menu %>% test_all_compliance_verbose()



# Take solution (a list resulting from solve_it()) and get the raw values of each of the nutrients in the
# solved menu
solve_nutrients <- function(sol) {
  
  solved_nutrient_value <- list(solution_nutrient_value =         # Grab the vector of nutrient values in the solution
                              sol$auxiliary$primal) %>% as_tibble()
  
  nut_df_small_solved <- sol$necessary_nutrients %>%       # cbind it to the nutrient requirements
    bind_cols(solved_nutrient_value)  %>% 
    rename(
      required_value = value
    ) %>% 
    select(nutrient, is_must_restrict, required_value, solution_nutrient_value)
  
  ratios <- nut_df_small_solved %>%                # Find the solution:required ratios for each nutrient
    mutate(
      ratio = solution_nutrient_value/required_value
    )
  
  max_pos_overshot <- ratios %>%             # Find where we've overshot our positives the most
    filter(is_must_restrict == FALSE) %>% 
    filter(ratio == max(.$ratio))
  
  message(paste0("We've overshot the most on ", max_pos_overshot$nutrient %>% as_vector()), 
          ". It's ", 
          max_pos_overshot$ratio %>% round(digits = 2), " times what is needed.")
  
  return(nut_df_small_solved)
}


# solve_nutrients(full_solution)
menu_unsolved_per_g %>% 
  solve_it(nutrient_df, only_full_servings = TRUE, min_food_amount = -3) %>% 
  solve_nutrients()

menu_unsolved_raw %>% 
  solve_it(nutrient_df, df_is_per_100g = FALSE) %>% 
  solve_nutrients()

solved_nutrients <- menu_unsolved_per_g %>% solve_it(nutrient_df) %>% solve_nutrients()



# -----------
# Start merging with old code

swapped_solved <- solved_menu %>% 
  select(NDB_No, Shrt_Desc, !!quo_nutrient_names, everything()) %>%  # get columns in old order
  smart_swap_single() 


score_menu(solved_menu)


