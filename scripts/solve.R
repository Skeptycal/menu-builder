# GNU solver
# https://cran.r-project.org/web/packages/Rglpk/Rglpk.pdf

source("./scripts/menu_builder_silent.R")   # Load all original menu building and tweaking functions but 
                                            # only create the original menu
# devtools::install_github("aedobbyn/dobtools", force = TRUE)
library(dobtools)
library(feather)
library(Rglpk)

# --------------------------------------------------------------------------------------------------
# Now in dobtools
grab_first_word <- function(e, splitter = " ") {
  stopifnot(is.character(e))
  
  e <- e %>% stringr::str_split(pattern = splitter, simplify = TRUE) %>% first()
  return(e)
}

is_plural <- function(word, return_bool = FALSE) {
  
  if(substr(word, nchar(word), nchar(word)) %>% tolower() == "s") {
    is_plural_bool <- TRUE
    word_to_say <- "them"
  } else {
    is_plural_bool <- FALSE
    word_to_say <- "it"
  }
  
  if(return_bool == TRUE) {
    return(is_plural_bool)
  } else {
    return(word_to_say)
  }
  
}
# --------------------------------------------------------------------------------------------------


# Quosure the nutrient and must restrict names
nutrient_names <- c(all_nut_and_mr_df$nutrient, "Energ_Kcal")
quo_nutrient_names <- quo(nutrient_names)

# Simplify our menu space
cols_to_keep <- c(all_nut_and_mr_df$nutrient, "Shrt_Desc", "GmWt_1", "Energ_Kcal", "NDB_No")
menu_unsolved_raw <- menu[, which(names(menu) %in% cols_to_keep)] %>% 
  mutate(
    shorter_desc = map_chr(Shrt_Desc, grab_first_word, splitter = ","), # Take only the fist word
    cost = runif(nrow(.), min = 1, max = 10) %>% round(digits = 2) # Add a cost column
  ) %>%
  select(shorter_desc, cost, !!quo_nutrient_names, GmWt_1, Shrt_Desc, NDB_No)

# Give nutrients a flag for whether they're a must-restrict or not
nutrient_df <- all_nut_and_mr_df %>% 
  bind_rows(list(nutrient = "Energ_Kcal",     # Add calorie restriction in
                 value = 2300) %>% as_tibble()) %>%
  mutate(
    is_must_restrict = ifelse(nutrient %in% mr_df$must_restrict, TRUE, FALSE)
  )


# -----------------------------------------
# What we have in our menu right now after it's just been generated by build_menu():
  # One serving of every food
  # Each nutrient's value represents how much of that nutrient we have per 100g 
  # GmWt_1 represents how many grams are in 1 serving of that food
  # To get the raw g of that nutrient, we have to multiply the nutrient per 100g value by GmWt_1 and divide by 100

# needs_transforming <- function(col) {
#   if (col %in% nutrient_names) {
#     needs_transforming <- TRUE
#   } else {
#     needs_transforming <- FALSE
#   }
#   return(needs_transforming)
# }
# 
# get_val_per_gram <- function(col) {
#   col = col * GmWt_1
#   return(col)
# }
# 
# menu_unsolved <- menu_unsolved_raw %>% 
#   transmute_if(needs_transforming, get_val_per_gram)


at_cols <- which(names(menu_unsolved_raw) %in% nutrient_names)

per_g_vals <- menu_unsolved_raw %>% 
  select(GmWt_1, !!quo_nutrient_names) %>%
  map_dfr(function(x) (x * .$GmWt_1)/100) %>%         # .at = at_cols
  select(-GmWt_1)

non_nut_cols <- menu_unsolved_raw[, setdiff(seq(1:ncol(menu_unsolved_raw)), at_cols)]

menu_unsolved <- per_g_vals %>% bind_cols(non_nut_cols) %>% 
  select(shorter_desc, cost, !!quo_nutrient_names, GmWt_1, Shrt_Desc, NDB_No)


# Transpose our menu such that it looks like the matrix of constraints we're about to create
# with foods as the columns and nutrients as the rows
transposed_menu_unsolved <- menu_unsolved %>% 
  select(cost, !!quo_nutrient_names) %>%   
  t() %>% as_data_frame() 

names(transposed_menu_unsolved) <- menu_unsolved$shorter_desc

transposed_menu_unsolved <- transposed_menu_unsolved %>%
  mutate(
    constraint = c("cost", nutrient_df$nutrient)
  ) %>% 
  select(constraint, everything())



# # # # # # # # # # # # # # # # # # # # Solve  # # # # # # # # # # # # # # # # # # # # # # # #

# Return a solution that contains the original menu and the needed nutrient df along with the rest
# of the solution in a list
solve_it <- function(df, nutrient_df, only_full_servings = FALSE, 
                     min_food_amount = 1, max_food_amount = 100, 
                     verbose = TRUE, v_v_verbose = FALSE, maximize = FALSE) {
  
  n_foods <- length(df$shorter_desc)
  nut_quo <- quo(nutrient_df$nutrient)
  
  dir_mr <- rep("<", nutrient_df %>% filter(is_must_restrict == TRUE) %>% ungroup() %>% count() %>% as_vector())       # And less than on all the must_restricts
  dir_pos <- rep(">", nutrient_df %>% filter(is_must_restrict == FALSE) %>% ungroup() %>% count() %>% as_vector())     # Final menu must be greater than on all the positives
  
  dir <- c(dir_mr, dir_pos)
  rhs <- nutrient_df[["value"]]      # The right-hand side of the equation is all of the min or max nutrient values
  obj_fn <- df[["cost"]]             # Objective function will be to minimize total cost
  
  bounds <- list(lower = list(ind = seq(n_foods), 
                              val = rep(min_food_amount, n_foods)),
                 upper = list(ind = seq(n_foods), 
                              val = rep(max_food_amount, n_foods)))
  construct_matrix <- function(df, nutrient_df) {       # Set up matrix constraints
    mat_base <- df %>% select(!!nut_quo) %>% as_vector()    # Get a vector of all our nutrients
    mat <- matrix(mat_base, nrow = nrow(nutrient_df), byrow = TRUE)       # One row per constraint, one column per food (variable)
    return(mat)
  }
  
  mat <- construct_matrix(df, nutrient_df)
  constraint_matrix <- mat %>% as_data_frame() 
  names(constraint_matrix) <- df$shorter_desc
  constraint_matrix <- constraint_matrix %>% 
    mutate(
      dir = dir,
      rhs = rhs
    ) %>% left_join(nutrient_df, by = c("rhs" = "value")) %>% 
    select(nutrient, everything())
  
  
  if(only_full_servings == TRUE) {
    types <- rep("I", n_foods)
  } else {
    types <- rep("C", n_foods)
  }
  
  if(v_v_verbose == TRUE) {
    v_v_verbose <- TRUE
    message("Constraint matrix below:")
    print(constraint_matrix)
  } else {
    v_v_verbose <- FALSE
  }
  
  out <- Rglpk_solve_LP(obj_fn, mat, dir, rhs,                    # Do the solving; we get a list back
                        bounds = bounds, types = types, 
                        max = maximize, verbose = v_v_verbose)   
  
  out <- append(append(append(                                           # Append the dataframe of all min/max nutrient values
    out, list(necessary_nutrients = nutrient_df)),
    list(constraint_matrix = constraint_matrix)),                        # our constraint matrix
    list(original_menu = df))                                            # and our original menu
  
  if (verbose == TRUE) {
    message(paste0("Cost is $", out$optimum %>% round(digits = 2), ".")) 
    if (out$status == 0) {
      message("Optimal solution found :)")
    } else {
      message("No optimal solution found :'(")
    }
  }
  
  return(out)
}

# solve_it(menu_unsolved, nutrient_df, only_full_servings = TRUE, v_v_verbose = TRUE, min_food_amount = 3)$solution
# solve_it(menu_unsolved, nutrient_df, only_full_servings = TRUE, min_food_amount = -3)$solution
# solve_it(menu_unsolved, nutrient_df, only_full_servings = FALSE, min_food_amount = 0.5)$solution
solve_it(menu_unsolved, nutrient_df)

full_solution <- solve_it(menu_unsolved, nutrient_df, min_food_amount = -3)



# Take a solution (a list resulting from solve_it()) and 
# return a menu with the solution column cbound as well as a helpful message
solve_menu <- function(sol, v_v_verbose = TRUE) {
  
  solved_col <-  list(solution_amounts = sol$solution) %>% as_tibble()    # Grab the vector of solution amounts
  
  df_solved <- sol$original_menu %>% bind_cols(solved_col) %>%            # cbind that to the original menu
    select(shorter_desc, solution_amounts, everything())
  
  max_food <- df_solved %>%                                   # Find what the most of any one food we've got is
    filter(solution_amounts == max(df_solved$solution_amounts)) %>% 
    slice(1:1)                                           # If we've got multiple maxes, take only the first
  
  if (v_v_verbose == TRUE) {
    message(paste0("We've got a lot of ", max_food$shorter_desc %>% as_vector()), ". ",
            max_food$solution_amounts %>% round(digits = 2), " grams of ",
            max_food$shorter_desc %>% as_vector() %>% is_plural(return_bool = FALSE), ".")  
  }
  
  return(df_solved)
}

# solve_menu(full_solution)
solved_menu <- menu_unsolved %>% solve_it(nutrient_df) %>% solve_menu()
compliant_solved <- solve_it(menu_unsolved, nutrient_df, only_full_servings = TRUE, min_food_amount = -10) %>% solve_menu()



# Take solution (a list resulting from solve_it()) and get the values of each of the nutrients in the
# solved menu
solve_nutrients <- function(sol) {
  
  solved_nutrient_value <- list(solution_nutrient_value =         # Grab the vector of nutrient values in the solution
                                  sol$auxiliary$primal) %>% as_tibble()
  
  nut_df_small_solved <- sol$necessary_nutrients %>%       # cbind it to the nutrient requirements
    bind_cols(solved_nutrient_value)  %>% 
    rename(
      required_value = value
    ) %>% 
    select(nutrient, is_must_restrict, required_value, solution_nutrient_value)
  
  ratios <- nut_df_small_solved %>%                # Find the solution:required ratios for each nutrient
    mutate(
      ratio = solution_nutrient_value/required_value
    )
  
  max_pos_overshot <- ratios %>%             # Find where we've overshot our positives the most
    filter(is_must_restrict == FALSE) %>% 
    filter(ratio == max(.$ratio))
  
  message(paste0("We've overshot the most on ", max_pos_overshot$nutrient %>% as_vector()), 
          ". It's ", 
          max_pos_overshot$ratio %>% round(digits = 2), " times what is needed.")
  
  return(nut_df_small_solved)
}


# solve_nutrients(full_solution)
solved_nutrients <- menu_unsolved %>% solve_it(nutrient_df) %>% solve_nutrients()
solve_it(menu_unsolved, nutrient_df, only_full_servings = TRUE, min_food_amount = -3) %>% solve_nutrients()
